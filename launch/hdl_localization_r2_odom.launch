<?xml version="1.0"?>
<launch>

  <param name="use_sim_time" value="true" />
    

  <!-- arguments -->
  <arg name="nodelet_manager" default="velodyne_nodelet_manager" />
  <arg name="points_topic" default="/laser_cloud_flat" />
  <!-- <arg name="points_topic" default="/livox_surf_point" /> -->
  <!-- <arg name="points_topic" default="/cloud_registered" /> -->

  <!-- input clouds are transformed in odom_child_frame, and then localization is performed in that frame -->
  <!-- this is useful to match the LIDAR and IMU coodinate systems -->
  <arg name="odom_child_frame_id" default="body" />
  <arg name="robot_odom_frame_id" value="world" />

  <!-- optional arguments -->
  <arg name="use_imu" default="true" />
  <arg name="invert_imu_acc" default="false" />
  <arg name="invert_imu_gyro" default="false" />
  <arg name="use_global_localization" default="true" />
  <arg name="imu_topic" default="/livox/imu" />
  <arg name="enable_robot_odometry_prediction" value="true" />

  <arg name="plot_estimation_errors" value="false" />

  <include file="$(find hdl_global_localization)/launch/hdl_global_localization.launch" if="$(arg use_global_localization)" />

  <!-- in case you use velodyne_driver, comment out the following line -->
  <node pkg="nodelet" type="nodelet" name="$(arg nodelet_manager)" args="manager" output="screen"/>



    <!-- hdl_localization_nodelet -->
    <node pkg="nodelet" type="nodelet" name="hdl_localization_nodelet" output="screen" args="standalone  hdl_localization/HdlLocalizationNodelet $(arg nodelet_manager)">
      <remap from="/velodyne_points" to="$(arg points_topic)" />
      <remap from="/gpsimu_driver/imu_data" to="$(arg imu_topic)" />
      <!-- odometry frame_id -->
      <param name="odom_child_frame_id" value="$(arg odom_child_frame_id)" />
      <!-- imu settings -->
      <!-- during "cool_time", imu inputs are ignored -->
      <param name="use_imu" value="$(arg use_imu)" />
      <param name="invert_acc" value="$(arg invert_imu_acc)" />
      <param name="invert_gyro" value="$(arg invert_imu_gyro)" />
      <param name="cool_time_duration" value="2.0" />
      <!-- robot odometry-based prediction -->
      <param name="enable_robot_odometry_prediction" value="$(arg enable_robot_odometry_prediction)" />
      <param name="robot_odom_frame_id" value="$(arg robot_odom_frame_id)" />
      <!-- ndt settings -->
      <!-- available reg_methods: NDT_OMP, NDT_CUDA_P2D, NDT_CUDA_D2D-->
      <param name="reg_method" value="NDT_OMP" />
      <!-- if NDT is slow for your PC, try DIRECT1 serach method, which is a bit unstable but extremely fast -->
      <param name="ndt_neighbor_search_method" value="DIRECT7" />
      <param name="ndt_neighbor_search_radius" value="3.0" /><!--  DIRECT7 是 不用这个参数的 -->

      
      <!-- outdoor  1.5 - 2.2 is ok -->
      <param name="ndt_resolution" value="1.2" />
      <param name="ndt_stepsize" value="0.15" />  
      <param name="downsample_resolution" value="0.1" />
      <param name="max_correspondence_dist" value="0.3" />
      <!-- 和地图的分辨率保持一致，后面用来计算 定位匹配度的 ，可以通过 rosparam set /hdl_localization_nodelet/max_correspondence_dist x 动态调整 -->

      <!-- indoor  0.5 is ok -->
      <!-- <param name="ndt_resolution" value="0.50" />
      <param name="ndt_stepsize" value="0.1" /> 
      <param name="downsample_resolution" value="0.1" />
      <param name="max_correspondence_dist" value="0.1" />  -->

      <!-- if "specify_init_pose" is true, pose estimator will be initialized with the following params -->
      <!-- otherwise, you need to input an initial pose with "2D Pose Estimate" on rviz" -->
      <param name="specify_init_pose" value="true" />

      <!-- -s 50  -->
      <!-- <param name="init_pos_x" value="49.141785" />
      <param name="init_pos_y" value="13.234248" />
      <param name="init_pos_z" value="0.873791" />
      <param name="init_ori_x" value="0.019173" />
      <param name="init_ori_y" value="-0.033902" />
      <param name="init_ori_z" value="0.716609" />
      <param name="init_ori_w" value="0.696387" /> -->
   
      <!-- -s 50  in big horizon map -->
      <param name="init_pos_x" value="-38.452869" />
      <param name="init_pos_y" value="88.591454" />
      <param name="init_pos_z" value="-1.192076" />
      <param name="init_ori_x" value="-0.006031" />
      <param name="init_ori_y" value="0.010420" />
      <param name="init_ori_z" value="0.994078" />
      <param name="init_ori_w" value="0.108001" />

      <!-- -s 450  -->
      <!-- <param name="init_pos_x" value="101.292259" />
      <param name="init_pos_y" value="-2.225581" />
      <param name="init_pos_z" value="1.764710" />
      <param name="init_ori_x" value="0.009990" />
      <param name="init_ori_y" value="0.004116" />
      <param name="init_ori_z" value="-0.991510" />
      <param name="init_ori_w" value="0.129581" />  -->

    
      <!-- -s 15  -1128  -->
      <!-- <param name="init_pos_x" value="17.860094" />
      <param name="init_pos_y" value="-12.593076" />
      <param name="init_pos_z" value="1.033428" />
      <param name="init_ori_x" value="0.014354" />
      <param name="init_ori_y" value="-0.011381" />
      <param name="init_ori_z" value="0.997482" />
      <param name="init_ori_w" value="0.068519" />  -->


      <param name="use_global_localization" value="$(arg use_global_localization)" />
    </node>

    <!-- <node pkg="hdl_localization" type="plot_status.py" name="plot_estimation_errors" if="$(arg plot_estimation_errors)" /> -->

</launch>
